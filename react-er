setInProgress(true);
    
    try {
        const fileList = await fetch(`http://aiws1:8081/chatbot/showsources?collection_name=${collectionName}`, { method: "POST" });
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const value = await fileList.json();
        setIndexFiles(value);
        setShowIndexedFile(true);
        console.log(showIndexedFile);
        setSelectedCollectionIndexFiles(indexFiles, collectionName);
    } catch (error) {
        // Handle any errors here
    } finally {
        setInProgress(false);
    }

try (
            // Establishing a connection to the database
            Connection connection = DriverManager.getConnection(url, user, password);
            // Retrieving stored procedure definition
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery("EXEC sp_helptext '" + storedProcedureName + "'");
        ) {
            // Processing the result set
            while (resultSet.next()) {
                String line = resultSet.getString(1);
                // Assuming the table name is mentioned in the stored procedure definition
                // You may need to adjust this logic based on how your stored procedures are written
                if (line.contains("YourTableName")) { // Replace with your table name
                    System.out.println("Table name found in stored procedure: " + line);
                    break;
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }






{
    "version": "0.2.0",
    "configurations": [
      {
        "type": "node",
        "request": "launch",
        "name": "Debug Nest Framework",
        "runtimeExecutable": "npm",
        "runtimeArgs": [
          "run",
          "start:debug",
          "--",
          "--inspect-brk"
        ],
        "autoAttachChildProcesses": true,
        "restart": true,
        "sourceMaps": true,
        "stopOnEntry": false,
        "console": "integratedTerminal",
      }
    ]
  }

https://youtu.be/GurZKf5M154?si=phTq2x0sMNIkXZB9


public static void main(String[] args) {
        // JDBC URL, username, and password of the SQL Server database
        String url = "jdbc:sqlserver://localhost:1433;databaseName=YourDatabaseName";
        String user = "YourUsername";
        String password = "YourPassword";

        // Path to your CSV file
        String csvFilePath = "path/to/your/csv/file.csv";

        try (
            // Establishing a connection to the database
            Connection connection = DriverManager.getConnection(url, user, password);
            // Creating a prepared statement for inserting data
            PreparedStatement preparedStatement = connection.prepareStatement(generateInsertQuery("YourTableName", getCSVColumnNames(csvFilePath)));
            // Creating a reader for the CSV file
            Reader reader = new FileReader(csvFilePath);
            // Parsing the CSV file
            CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withHeader());
        ) {
            // Iterating over each record in the CSV file
            for (CSVRecord csvRecord : csvParser) {
                // Inserting data into the table
                for (int i = 0; i < csvRecord.size(); i++) {
                    preparedStatement.setString(i + 1, csvRecord.get(i));
                }
                preparedStatement.executeUpdate();
            }
            System.out.println("Data inserted successfully.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Method to generate the SQL INSERT query dynamically based on column names
    private static String generateInsertQuery(String tableName, List<String> columnNames) {
        StringBuilder queryBuilder = new StringBuilder();
        queryBuilder.append("INSERT INTO ").append(tableName).append(" (");
        for (int i = 0; i < columnNames.size(); i++) {
            queryBuilder.append(columnNames.get(i));
            if (i < columnNames.size() - 1) {
                queryBuilder.append(", ");
            }
        }
        queryBuilder.append(") VALUES (");
        for (int i = 0; i < columnNames.size(); i++) {
            queryBuilder.append("?");
            if (i < columnNames.size() - 1) {
                queryBuilder.append(", ");
            }
        }
        queryBuilder.append(")");
        return queryBuilder.toString();
    }

    // Method to extract column names from the first row of the CSV file
    private static List<String> getCSVColumnNames(String csvFilePath) throws Exception {
        Reader reader = new FileReader(csvFilePath);
        CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withHeader());
        List<String> columnNames = new ArrayList<>(csvParser.getHeaderMap().keySet());
        reader.close();
        csvParser.close();
        return columnNames;
    }




List<String> columnNames = new ArrayList<>();
        FileInputStream fis = new FileInputStream(new File(excelFilePath));
        Workbook workbook = WorkbookFactory.create(fis);
        Sheet sheet = workbook.getSheetAt(0);
        Row headerRow = sheet.getRow(0);
        for (int i = 0; i < headerRow.getLastCellNum(); i++) {
            Cell cell = headerRow.getCell(i);
            columnNames.add(cell.getStringCellValue());
        }
        fis.close();
        return columnNames;




 // Getting the first sheet from the workbook
            Sheet sheet = workbook.getSheetAt(0);

            // Iterating over each row in the sheet
            Iterator<Row> rowIterator = sheet.iterator();
            while (rowIterator.hasNext()) {
                Row row = rowIterator.next();
                if (row.getRowNum() == 0) continue; // Skip the header row
                // Inserting data into the table
                for (int i = 0; i < row.getLastCellNum(); i++) {
                    preparedStatement.setString(i + 1, row.getCell(i).getStringCellValue());
                }
                preparedStatement.executeUpdate();
            }


 // Creating a FileInputStream for the Excel file
                FileInputStream fis = new FileInputStream(new File(excelFilePath));
                // Creating a workbook instance from the Excel file
                Workbook workbook = WorkbookFactory.create(fis);









import com.azure.identity.ClientSecretCredential;
import com.azure.identity.ClientSecretCredentialBuilder;
import com.azure.security.keyvault.secrets.SecretClient;
import com.azure.security.keyvault.secrets.SecretClientBuilder;
import com.azure.security.keyvault.secrets.models.KeyVaultSecret;

public class KeyVaultExample {
    public static void main(String[] args) {
        // Replace with your Key Vault and Azure AD details
        String keyVaultName = "your-key-vault-name";
        String keyVaultUrl = "https://" + keyVaultName + ".vault.azure.net";
        String tenantId = "your-tenant-id";
        String clientId = "your-client-id";
        String clientSecret = "your-client-secret";
        
        // Authenticate with Azure AD
        ClientSecretCredential clientSecretCredential = new ClientSecretCredentialBuilder()
                .tenantId(tenantId)
                .clientId(clientId)
                .clientSecret(clientSecret)
                .build();

        // Create a SecretClient
        SecretClient secretClient = new SecretClientBuilder()
                .vaultUrl(keyVaultUrl)
                .credential(clientSecretCredential)
                .buildClient();

        // Retrieve a secret from the Key Vault
        KeyVaultSecret secret = secretClient.getSecret("your-secret-name");

        // Use the secret
        System.out.println("Secret Value: " + secret.getValue());
    }
}










import com.azure.identity.ClientSecretCredential;
import com.azure.identity.ClientSecretCredentialBuilder;
import com.azure.security.keyvault.keys.KeyClient;
import com.azure.security.keyvault.keys.KeyClientBuilder;
import com.azure.security.keyvault.keys.cryptography.CryptographyClient;
import com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;
import com.azure.security.keyvault.keys.models.KeyVaultKey;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class KeyVaultEncryptionExample {
    public static void main(String[] args) throws Exception {
        // Replace with your Key Vault details
        String keyVaultName = "your-key-vault-name";
        String keyVaultUrl = "https://" + keyVaultName + ".vault.azure.net";
        String tenantId = "your-tenant-id";
        String clientId = "your-client-id";
        String clientSecret = "your-client-secret";
        String keyName = "your-encryption-key-name";

        // Authenticate with Azure AD
        ClientSecretCredential clientSecretCredential = new ClientSecretCredentialBuilder()
                .tenantId(tenantId)
                .clientId(clientId)
                .clientSecret(clientSecret)
                .build();

        // Create a KeyClient
        KeyClient keyClient = new KeyClientBuilder()
                .vaultUrl(keyVaultUrl)
                .credential(clientSecretCredential)
                .buildClient();

        // Retrieve the encryption key from Key Vault
        KeyVaultKey keyVaultKey = keyClient.getKey(keyName);

        // Extract the key bytes (assuming it's a symmetric key)
        byte[] keyBytes = Base64.getDecoder().decode(keyVaultKey.getKey().toString());

        // Create a SecretKeySpec
        SecretKey secretKey = new SecretKeySpec(keyBytes, "AES");

        // Data to be encrypted
        String data = "Hello, this is a secret message!";

        // Perform encryption
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        byte[] encryptedData = cipher.doFinal(data.getBytes());

        // Print encrypted data
        System.out.println("Encrypted Data: " + Base64.getEncoder().encodeToString(encryptedData));

        // Perform decryption
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        byte[] decryptedData = cipher.doFinal(encryptedData);

        // Print decrypted data
        System.out.println("Decrypted Data: " + new String(decryptedData));
    }
}











